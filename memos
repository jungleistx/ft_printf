*** *** *** *** *** 		printf		 *** *** *** *** *** ***

		neg						pos & 0
space	zero | minus | w<len R	w--
		else 	w--

		all same
width	PLUS=w--, w-res (w-prec | w-len)

prefix	write only -			write +, w--

		all same
prec	ZERO= w-res (w-len) else: w-prec, prec = 0

num		w-(len + 1)				w-len

		all same
minus	DOT: w-prec				if w>0: write w


+ - ' ' . 0

not
- 0
+ ' '





% +-0-+* .* d


TOCHECK
	%cd with length (h and l etc)
	%d prec vs width

arg_len ++ when negative in neg_number

*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*
*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*
*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*
*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*
mess with numbers, where is flags and padding handled ---- TODO ----
*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*
*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*
*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*
*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*
*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*









with flags: 				none		hh 				h 			l 			ll				L
d	signed deci int			int			signed char		short		long		long long
i 	-||-					&			&&				&			&			&
c	char					&

o	unsig octal				unsig int	unsig char		unsg shrt	unsig long	unsig long long
u	unsig deci int			&			&&				&			&			&
x	unsig deci int			&			&&				&			&			&
X	unsig hex int (upper)	&			&&				&			&			&

s 	string					char*
p 	pointer address			void*

f	float					double		-				-			long double?	-			long double
	numbers after . is equal to precision spec. if missing, default is 6
	if precision is 0, no decimal point char appear. if decimal point appears, atleast
	one digit must be before that
n	num written so far		int*		signed char*							long long*

ORDER
	padding	(space. if +, ignore)
	prefix
	0	(if ->dot, ignore)
	%d
	padd

	==
	space
	num(before.)
	0 (amount of becomes from )

	4 / *	.	4 / *

-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-
-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-
-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-
-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-
-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-

	% [flags][width][.precision][length]specifier

-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-
-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-
-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-
-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-
-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-


SPECIAL CASES
	. and 0		(nothing after .) doesnt matter because num_len > length (try with 0?)
	. 			(float < 0 gives atleast 1 number before .)

COMBOS NOT WORKING
	- 0
	+ ' '

FLAGS
%		putchar '%'

-		negative field. converted value is pad added to right with blanks.
		default padding is left. field input given.

+		must be placed before a number produced by signed conversion overwrites ' ' if both used
		forces + before num, default is only minus
		doesnt affect width, +5 = write(6)

' '		blank left produced by signed conversion (d, f, i) (padding)
		if negative && prec > width, ignore (doesnt prec--)

#		alternate, no effect for 'cdinpsu'
		For o, force first char to 0
		for x and X, nonzero result has the string 0x or 0X.
		for f, result will always contain a decimal point, even if no digits follow
			default is no decimal point

0		padding for all types. if precision given, 0 is ignored.
		width specified.

WIDTH
Number
	Min number to print. If number is smaller (count digits) than this, padding added.
*
	Argument list contains width value before printed value
	minimun amount printed. if less, no effect. if more, add padding right <> left

/*
*	precision (or *followed by 1 <= digits and 'dollar' instead of digit string. this case int gives
	the amount of digits). minimum amount of numbers to be given. if less, add padding
-minimum field width (.?)

*/ ???

PRECISION
.number
	For dioux, num is min numbers to write. If digits < num, leading 0 padding added.
	0 means no char written for the value 0 (?)
	For f, num means after decimal point. Default is 6
	For s, num is max number to write.
	If only period, 0 is assumed
.*
	Precision not specified in str, but as an va_arg

NOTES
c
	-num && num (width)
s
	if .num added, thats maximum to print
	-num?
f
	autocasts to double (long double?, holds every value straight)
	Ignore zero padded .03 float (?)
f round
	If .5, round to even nbr -> 1.5 = 2, 2,5 = 2
	: .5595 - .559 and .560 -.5595
	If first bigger. Round up
	Double holds 16 digits
	basic len = 6
	if 0, no len
	if . atleast 1 num before .
	bankers rounding
	if # and prec 0:	print '.' after num
x
	if 0, hash not included (print '0x')
	else 0x <value>
random
	write returns #written
	Va_arg takes int and casted to unsig char, rather than va_arg unsig char
	First collect significant info in str and then formats/zeroes/spaces as you go
	Invalid flag undefined
	Hex 0x0, bits 0b0
	Global static const
	O3 flag compilation
	output error returns negative
	static const arr of func pointers aka dispatch table
	aka dispatch table (printf.h=)
	flags in uint16_t
	minimum allocation, modify and print

/*	NOTES

if prec > width || prec > arglen
	write 0

if width > prec
	while if = true
		write ' '
	while prec > arglen
		write 0

- +
	if w < prec, + doesnt affect total len
%+-4.6d         |+000099|       |-000099|
%+-6.4d         |+0099 |        |-0099 |

cases
%06.4d          |  0099|        | -0099|
%04.6d          |000099|        |-000099|
*/

needed ?
	ftoa
	itoa
	buf[10] for flags, precision, field, width (?)

BONUS
-n 	num printed so far		int* 	sig char*			short*			long *		longlong*
-Uppercase D, I etc

	from printf manual
following appear in sequence:
	optional field:
		decimal digit string, followed by 'dollarsign'. if no dollar, next arg is read
	zero or more following flags:
-colors	(same as printf / .sh)

TODO
- numbercounter that takes void*, can be used with all numbers. converts to longlong
- putchar multi instead of write(more than 1)

LIBFT_FUNCTIONS
putstr
putnbr
putchar
strlen
isdigit

BONUS
-%n 	amount written at that moment, saved in (total?)
-color	output, same as printf and .sh
-%zu 	same as %l, takes sizeof

TESTCASES 			(d = 9)
	all
Too long output? 16bit, example with 4 bit: 42.4242 (6bit)
long long min
- 0, + ' '		error flags
h and 0 in different order, or l and 0 etc
duplicate flags		%+++-++-+4.4d
multiple hh or lll or mixed hlhlhlh
.0 (precision 0)
testing with negative *
null pointer, empty string, int 0
return values
	d i
04d, 4d --> 0009, _ _ _9
*4d, : _ _ _ 9 // width added as input
(”*d”, 3, num) : _ _ 9 // width added as argument
int 0 with all different flag combos
.0 (precision 0) int 0, prints nothing?
	float
printf("%Lf\n", -0.0L);
bankers rounding only if .0 flag TEST
	char
%c as null, width 12 + null
char c = 0;
	octal
octal 0 with flags (prec 0 )


.ZSHRC
PROMPT='%F{45}%D, %T%f %F{190}%~%f%F{40} %#%f '
alias gca="gcc -S -masm=intel"
alias objdump="objdump -d -x86-asm-syntax=intel"
alias gg="gcc -g"
alias gdb="gdb -q"
HOMEBREW_NO_ANALYTICS=1
alias bc="bc -l -q"
alias l="ls -lhS"
alias la="ls -laphS"
alias lr="ls -lR"

---

0 1 2 3 4 5 6 7 8  9  10
r a n d o m _ % d \n \n          // len(6), int 9, total = 6 + (spc 1) + 1 + \n + \n = 9

?
%e scientific format number
Mantissa (total bits?)

Arena script
Check unicode for d, esc
D = U+0064 decimal 100 oct 144
Esc = decimal 27 hex x1b u+001b?? Oct 33




checked flags 	OK
check spec 	- 	func_pointer TODO


EVAL
pre
	git
	norm
	author
	forbidden
simple
	%s
	%p
	%d
	%%
less simple
	multiple conv
	multiple args of same type
slightly comp
	%i
	%o
	%u
	%x
	%X
	%c
complicated
	multiple convs of different size
	int char int
more comp
	flags # 0 - + ' ' fieldwidth
more stuff
	%h
	%hh
	%l
	%ll with diouxX
	%l %L with f
finally
	flag .
BONUS



ELLA
^
titus	B2	^

1		2		3		4		F5
chen 	a1		kce/I1	h/e

hmar 	E
ehelm	E

_
jjun	F
spuu	B1

1		2		3		4		F5
max		jun 	kiwi	spuu

--
wins
scoring diff
repricocal match
if tie, highest points


