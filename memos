*** *** *** *** *** 		printf		 *** *** *** *** *** ***

		neg						pos & 0
space	zero | minus | w<len R	w--
		else 	w--

		all same
width	PLUS=w--, w-res (w-prec | w-len)

prefix	write only -			write +, w--

		all same
prec	ZERO= w-res (w-len) else: w-prec, prec = 0

num		w-(len + 1)				w-len

		all same
minus	DOT: w-prec				if w>0: write w


+ - ' ' . 0

not
- 0
+ ' '

% +-0-+* .* d


TOCHECK
	%cd with length (h and l etc)
	%d prec vs width
	%o 	with undefined flags + and ' '
	if . and NO PREC, dont jump
	length conversion: convert to smaller type and back
	%x undefined + and ' '


LIBFT_FUNCTIONS
ft_atoi
ft_isdigit
ft_putchar
ft_strlen

ft_putstr
ft_putnbr	(?) ft_putnbr_l might replace that


UNUSED
	check_octal_flags
	assign_octal
	write_percent
	print_zero_flag
		assign_number			?
		neg_number
	exit_error
	check_error_input
---
---
---
flags2.c
	dot_flag
	ast_precision_flag
	dot_ast_flag
flags.c
	special_flags
	check_len_flags
	digit_minus_flag
	plus_space_flag
helpers.c
	count_digits
	ft_putchar_multi
	ft_putnbr_l
percent.c
	print_percent
unsigned.c
	print_zero_unsig
	print_unsigned
	print_unsigned_long
string.c
	assign_str
	print_str
int_flags.c
	print_prec_flag
	print_width
char.c
	print_char
address.c
	print_address
ft_printf.c
	reset_info
	write_non_percent
	check_flags
	check_specifier
	ft_printf
int.c
	print_prefix_flag
	(print_space_flag)		DELETED
	print_zero_number
	print_number
bonus.c
	calc_printed			TEST WITH LENGHTS (ll, hh)
		toadd
			assign_binary
			print_binary
			print_sizeof
assing.c
	assign_dic
	assign_oux				func_name changed !
	float_rounding
	assign_float_to_ints
	assign_float
hex.c
	print_zero_hex
	count_hex
	print_hex
	print_hex_flags
hex_flags.c
	print_hex_zero_width
	print_hex_width
	print_hex_minus
octal_flags.c
	print_zero_octal_flags
octal.c
	print_zero_octal
	convert_octal
	print_octal_non_minus
	print_octal_minus
	print_octal
float.c
	float_calc_total
	print_float_flags
	print_float
--

with flags: 				none		hh 				h 			l 			ll				L
d	signed deci int			int			signed char		short		long		long long
i 	-||-					&			&&				&			&			&
c	char					&

o	unsig octal				unsig int	unsig char		unsg shrt	unsig long	unsig long long
u	unsig deci int			&			&&				&			&			&
x	unsig deci int			&			&&				&			&			&
X	unsig hex int (upper)	&			&&				&			&			&

s 	string					char*
p 	pointer address			void*

f	float					double		-				-			long double?	-			long double
	numbers after . is equal to precision spec. if missing, default is 6
	if precision is 0, no decimal point char appear. if decimal point appears, atleast
	one digit must be before that
n	num written so far		int*		signed char*							long long*

ORDER
	padding	(space. if +, ignore)
	prefix
	0	(if ->dot, ignore)
	%d
	padd

	==
	space
	num(before.)
	0 (amount of becomes from )

	4 / *	.	4 / *

-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-
-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-
	% [flags][width][.precision][length]specifier
-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-
-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-

SPECIAL CASES
	. and 0		(nothing after .) doesnt matter because num_len > length (try with 0?)
	. 			(float < 0 gives atleast 1 number before .)

COMBOS NOT WORKING
	- 0
	+ ' '

FLAGS
%		putchar '%'

-		negative field. converted value is pad added to right with blanks.
		default padding is left. field input given.

+		must be placed before a number produced by signed conversion overwrites ' ' if both used
		forces + before num, default is only minus
		doesnt affect width, +5 = write(6)

' '		blank left produced by signed conversion (d, f, i) (padding)
		if negative && prec > width, ignore (doesnt prec--)

#		alternate, no effect for 'cdinpsu'
		For o, force first char to 0
		for x and X, nonzero result has the string 0x or 0X.
		for f, result will always contain a decimal point, even if no digits follow
			default is no decimal point

0		padding for all types. if precision given, 0 is ignored.
		width specified.

WIDTH
Number
	Min number to print. If number is smaller (count digits) than this, padding added.
*
	Argument list contains width value before printed value
	minimun amount printed. if less, no effect. if more, add padding right <> left

/*
*	precision (or *followed by 1 <= digits and 'dollar' instead of digit string. this case int gives
	the amount of digits). minimum amount of numbers to be given. if less, add padding
-minimum field width (.?)

*/ ???

PRECISION
.number
	For dioux, num is min numbers to write. If digits < num, leading 0 padding added.
	0 means no char written for the value 0 (?)
	For f, num means after decimal point. Default is 6
	For s, num is max number to write.
	If only period, 0 is assumed
.*
	Precision not specified in str, but as an va_arg

NOTES
c
	-num && num (width)
s
	if .num added, thats maximum to print
	-num?
f
	autocasts to double (long double?, holds every value straight)
	Ignore zero padded .03 float (?)
f round
	If .5, round to even nbr -> 1.5 = 2, 2,5 = 2
	: .5595 - .559 and .560 -.5595
	If first bigger. Round up
	Double holds 16 digits
	basic len = 6
	if 0, no len
	if . atleast 1 num before .
	bankers rounding
	if # and prec 0:	print '.' after num
x
	if 0, hash not included (print '0x')
	else 0x <value>
random
	write returns #written
	Va_arg takes int and casted to unsig char, rather than va_arg unsig char
	First collect significant info in str and then formats/zeroes/spaces as you go
	Invalid flag undefined
	Hex 0x0, bits 0b0
	Global static const
	O3 flag compilation
	output error returns negative
	static const arr of func pointers aka dispatch table
	aka dispatch table (printf.h=)
	flags in uint16_t
	minimum allocation, modify and print

/*	NOTES

if prec > width || prec > arglen
	write 0

if width > prec
	while if = true
		write ' '
	while prec > arglen
		write 0

*/

READY BONUS:
	%n		value so far written, saved to &int
	*		wildcard width/prec, given as argument
	colors	used with %s (no "" around), defined in header
	%b		binary
	upper	U, D

BONUS
-n 	num printed so far		int* 	sig char*			short*			long *		longlong*
-Uppercase D, I etc
UPPERCASE = lowecase + l
	from printf manual
following appear in sequence:
	optional field:
		decimal digit string, followed by 'dollarsign'. if no dollar, next arg is read
	zero or more following flags:

BONUS
-%n 	amount written at that moment, saved in (total?)
-color	output, same as printf and .sh
-%zu 	same as %l, takes sizeof
-*		wildcard width/precision

TESTCASES 			(d = 9)
	all
Too long output? 16bit, example with 4 bit: 42.4242 (6bit)
long long min
- 0, + ' '		error flags
h and 0 in different order, or l and 0 etc
duplicate flags		%+++-++-+4.4d
multiple hh or lll or mixed hlhlhlh
.0 (precision 0)
testing with negative *
null pointer, empty string, int 0
return values
	d i
04d, 4d --> 0009, _ _ _9
*4d, : _ _ _ 9 // width added as input
(”*d”, 3, num) : _ _ 9 // width added as argument
int 0 with all different flag combos
.0 (precision 0) int 0, prints nothing?
	float
printf("%Lf\n", -0.0L);
bankers rounding only if .0 flag TEST
	char
%c as null, width 12 + null
char c = 0;
	octal
octal 0 with flags (prec 0 )

.ZSHRC
PROMPT='%F{45}%D, %T%f %F{190}%~%f%F{40} %#%f '
alias gca="gcc -S -masm=intel"
alias objdump="objdump -d -x86-asm-syntax=intel"
alias gg="gcc -g"
alias gdb="gdb -q"
HOMEBREW_NO_ANALYTICS=1
alias bc="bc -l -q"
alias l="ls -lhS"
alias la="ls -laphS"
alias lr="ls -lR"

---

0 1 2 3 4 5 6 7 8  9  10
r a n d o m _ % d \n \n          // len(6), int 9, total = 6 + (spc 1) + 1 + \n + \n = 9

?
%e scientific format number
Mantissa (total bits?)

		Arena script
		Check unicode for d, esc
		D = U+0064 decimal 100 oct 144
		Esc = decimal 27 hex x1b u+001b?? Oct 33

EVAL
pre
	git
	norm
	author
	forbidden
simple
	%s
	%p
	%d
	%%
less simple
	multiple conv
	multiple args of same type
slightly comp
	%i
	%o
	%u
	%x
	%X
	%c
complicated
	multiple convs of different size
	int char int
more comp
	flags # 0 - + ' ' fieldwidth
more stuff
	%h
	%hh
	%l
	%ll with diouxX
	%l %L with f
finally
	flag .
BONUS
